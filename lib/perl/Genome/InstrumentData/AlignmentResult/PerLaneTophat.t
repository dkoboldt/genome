#!/usr/bin/env genome-perl
use strict;
use warnings;

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
};
use Test::More;
use above "Genome";
use Genome::Utility::Test qw(compare_ok);
use Genome::Test::Factory::SoftwareResult::User;
use File::Basename;

my $TOPHAT_VERSION = '2.0.8';
my $BOWTIE_VERSION = '2.1.0';

sub _join {
    return File::Spec->join(@_);
}

my $class = 'Genome::InstrumentData::AlignmentResult::PerLaneTophat';
use_ok($class);

do { # _aliger_params_has_gtf tests
    my $f = \&Genome::InstrumentData::AlignmentResult::PerLaneTophat::_aliger_params_has_gtf;
    my @tests = (
        ['-G foo',     1],
        [' -G foo',    1],
        ['--GTF foo',  1],
        [' --GTF foo', 1],
        ['foo-G',      0],
        ['-Gfoo',      1], # Should this one match or not?
    );
    for my $test (@tests) {
        my ($s, $e) = @$test;
        my $n = '_aliger_params_has_gtf: ' . ($e ? "did match: $s" : "did not match: $s");
        is($f->($s), $e, $n);
    }
};

my $data_dir = Genome::Utility::Test->data_dir($class, 1);
ok(-d $data_dir, "data_dir exists: $data_dir") or die;

my $temp_input_dir = Genome::Sys->create_temp_directory();
Genome::Sys->rsync_directory(
        source_directory => _join($data_dir, 'input'),
        target_directory => _join($temp_input_dir),
);
my $reference_fasta = _join($temp_input_dir, 'all_sequences.fa');
my $gtf_file = _join($temp_input_dir, 'all_sequences.gtf');


# _generate_fake_reads_file
my $fake_reads_file = $class->_generate_fake_reads_file($reference_fasta, $gtf_file);
ok(-s $fake_reads_file, "found fake reads file: $fake_reads_file");



my $starting_aligner_params = "--bowtie-version=$BOWTIE_VERSION";
my ($reference_build, $annotation_build, $aligner_index, $annotation_index) = _create_entities($starting_aligner_params);

# _get_gtf_file
my $found_gtf_file = $class->_get_gtf_file($annotation_index);
is($found_gtf_file, $gtf_file, 'Looked up correct gtf_file');

# _get_aligner_params_to_generate_annotation_index
my $index_prefix = _join($temp_input_dir, 'all_sequences');
$annotation_index->aligner_params($starting_aligner_params);
my $expected_aligner_params =
    " --transcriptome-only --transcriptome-index '$index_prefix' -G $gtf_file --output-dir";
my $aligner_params = $class->_get_aligner_params_to_generate_annotation_index(
    $annotation_index, $gtf_file, $index_prefix,
);
# --output-dir will be a newly created temp_directory so we won't match that.
is(substr($aligner_params, 0, length($expected_aligner_params)),
    $expected_aligner_params, "Constructed aligner_params correctly");

Genome::Sys->rsync_directory(
        source_directory => _join($aligner_index->output_dir),
        target_directory => _join($temp_input_dir),
        file_pattern => 'all_sequences.fa.*',
);

# _get_reference_fasta
my $found_reference_fasta = $class->_get_reference_fasta($annotation_index);
is($found_reference_fasta, $aligner_index->full_consensus_path("fa"), 'Looked up correct reference_fasta');

my $expected_dir = _join($data_dir, 'expected', '*');
my @expected_files = glob($expected_dir);
for my $expected_file (@expected_files) {
    my $filename = basename($expected_file);
    my $output_file = _join($annotation_index->output_dir, $filename);
    compare_ok($output_file, $expected_file, name => "$filename matches expected", diag => 1);
}

done_testing();


sub _create_entities {
    my $aligner_params = shift;
    my $human = Genome::Taxon->create(name => 'test-taxon', domain => 'Unknown');

    # create the reference sequence model and build
    my $reference_pp = Genome::ProcessingProfile::ImportedReferenceSequence->create(name => 'test_ref_pp');
    my $reference_model = Genome::Model::ImportedReferenceSequence->create(
        name => '1 chr test model',
        subject => $human,
        processing_profile => $reference_pp,
    );
    ok($reference_model, 'Created reference model');

    my $reference_build = Genome::Model::Build::ImportedReferenceSequence->create(
        model => $reference_model,
        fasta_file => $reference_fasta,
        data_directory => $temp_input_dir,
        version => '37'
    );
    ok($reference_build, 'Created reference build');
    *Genome::Model::ImportedReferenceSequence::last_complete_build = sub {return $reference_build};

    my $result_users = Genome::Test::Factory::SoftwareResult::User->setup_user_hash(
        reference_sequence_build => $reference_build,
    );

    # create the annotation model and build.
    my $annotation_pp = Genome::ProcessingProfile::ImportedAnnotation->create(
        name              => 'test_annotation_pp',
        annotation_source => 'test_source',
    );
    my $annotation_model = Genome::Model::ImportedAnnotation->create(
        name                => "test_annotation",
        processing_profile  => $annotation_pp,
        subject_class_name  => ref($human),
        subject_id          => $human,
        reference_sequence  => $reference_model,
    );
    ok($annotation_model, "Created annotation model");


    $annotation_build = Genome::Model::Build::ImportedAnnotation->create(
        model               => $annotation_model,
        data_directory      => $temp_input_dir,
        version             => 1,
    );
    *Genome::Model::Build::ImportedAnnotation::annotation_file = sub {return $gtf_file};
    ok($annotation_build, "Created annotation build");

    my $aligner_index = Genome::Model::Build::ReferenceSequence::AlignerIndex->create(
        reference_build => $reference_build,
        aligner_name => 'PerLaneTophat',
        aligner_version => $TOPHAT_VERSION,
        aligner_params => $starting_aligner_params,
        _user_data_for_nested_results => $result_users,
    );
    ok($aligner_index, 'created aligner_index');

    my $annotation_index = Genome::Model::Build::ReferenceSequence::AnnotationIndex->create(
        annotation_build => $annotation_build,
        reference_build => $reference_build,
        aligner_name => 'PerLaneTophat',
        aligner_params => $aligner_params,
        aligner_version => $TOPHAT_VERSION,
        _user_data_for_nested_results => $result_users,
    );
    ok($annotation_index, 'Defined an annotation index');

    return $reference_build, $annotation_build, $aligner_index, $annotation_index;
}

1;
